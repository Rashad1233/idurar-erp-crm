// Load models with updated logger for diagnostics
const {
  PurchaseRequisition,
  PurchaseRequisitionItem,
  User,
  Contract,
  Supplier,
  ItemMaster,
  Inventory,
  sequelize
} = require('../models/sequelize');

// Load additional models directly to avoid export issues
const ApprovalHistoryModel = require('../models/sequelize/ApprovalHistory');
const DelegationOfAuthorityModel = require('../models/sequelize/DelegationOfAuthority');

// Initialize the models with sequelize instance
const ApprovalHistory = ApprovalHistoryModel(sequelize, require('sequelize').DataTypes);
const DelegationOfAuthority = DelegationOfAuthorityModel(sequelize, require('sequelize').DataTypes);
const { Op } = require('sequelize');
const { generateNextNumber } = require('../utils/numberGenerator');

// Create models object with both capitalized and lowercase aliases
const models = {
  PurchaseRequisition,
  purchaserequisition: PurchaseRequisition,
  PurchaseRequisitionItem,
  purchaserequisitionitem: PurchaseRequisitionItem,
  Supplier,
  supplier: Supplier,
  Inventory,
  inventory: Inventory,
  ItemMaster,
  itemmaster: ItemMaster,
  User,
  user: User,
  Contract,
  contract: Contract,
  ApprovalHistory,
  approvalhistory: ApprovalHistory,
  DelegationOfAuthority,
  delegationofauthority: DelegationOfAuthority
};

// Debug logging for model verification
console.log(`üîç PurchaseRequisition model check:`, {
  tableName: PurchaseRequisition?.tableName || 'Not defined',
  attributes: Object.keys(PurchaseRequisition?.rawAttributes || {}).slice(0, 5).join(', ') + '...',
  primaryKeyField: PurchaseRequisition?.primaryKeyField || 'Not defined'
});

// Generate a PR number (format: PR-YYYYMMDD-XXXX)
const generatePRNumber = async () => {
  const prefix = 'PR';
  return generateNextNumber(prefix, PurchaseRequisition);
};

// Get approval chain for a PR based on amount and cost center
const getApprovalChain = async (amount, costCenter, transaction) => {
  try {
    console.log(`üîç Getting approval chain for amount: ${amount}, costCenter: ${costCenter}`);
    
    const approvers = await DelegationOfAuthority.findAll({
      where: { 
        costCenter: costCenter || null, // If null, applies to all cost centers
        documentType: ['PR', 'All'],
        isActive: true,
        amountFrom: { [Op.lte]: amount },
        amountTo: { [Op.gte]: amount },
        [Op.or]: [
          { endDate: null }, // No end date
          { endDate: { [Op.gte]: new Date() } } // End date is in the future
        ],
        startDate: { [Op.lte]: new Date() } // Start date is in the past
      },
      include: [{
        model: User,
        as: 'user',
        attributes: ['id', 'name', 'email']
      }],
      order: [['approvalLevel', 'ASC']],
      transaction
    });

    console.log(`‚úÖ Found ${approvers.length} approvers in chain`);
    return approvers;
  } catch (error) {
    console.error('‚ùå Error getting approval chain:', error);
    return [];
  }
};

// Send email notification to approver
const notifyApprover = async (pr, approver) => {
  try {
    // Send email notification (implement your email sending logic here)
    console.log(`‚úâÔ∏è Would send approval notification to ${approver.email} for PR ${pr.prNumber}`);
    
    // Email content would include:
    // - PR number and details
    // - Link to approve/reject
    // - Total amount and other relevant information
  } catch (error) {
    console.error('Error sending approval notification:', error);
  }
};

// @desc    Create a new purchase requisition
// @route   POST /api/procurement/purchase-requisition
// @access  Private
exports.createPurchaseRequisition = async (req, res) => {
  const transaction = await sequelize.transaction();
  
  try {
    console.log('üìù Received purchase requisition data:', JSON.stringify(req.body, null, 2));
    
    const { 
      description, 
      costCenter, 
      currency, 
      approverId,
      notes,
      items,
      totalValue,
      requiredDate,
      number,
      fallbackNumber 
    } = req.body;
    
    // Check if user is authenticated
    if (!req.user || !req.user.id) {
      return res.status(401).json({
        success: false,
        message: 'Authentication required. User ID not found.'
      });
    }
      // Validate required fields
    if (!description || !costCenter || !items || !items.length) {
      console.log('‚ùå Validation failed:', { description: !!description, costCenter: !!costCenter, items: items?.length });
      await transaction.rollback();
      return res.status(400).json({
        success: false,
        message: 'Please provide all required fields: description, costCenter, and items'
      });
    }
    
    console.log('‚úÖ Validation passed, creating PR...');
      // Generate PR number if not provided
    const prNumber = number || fallbackNumber || await generatePRNumber();
    
    // Use totalValue from frontend if provided, otherwise calculate
    let totalAmount = totalValue || 0;
    if (!totalValue) {
      for (const item of items) {
        if (item.unitPrice && item.quantity) {
          totalAmount += parseFloat(item.unitPrice) * parseFloat(item.quantity);
        }
      }
    }      // Create the purchase requisition
    console.log('üìù Creating PR with data:', {
      prNumber,
      description,
      status: 'draft',
      totalAmount,
      currency: currency || 'USD',
      costCenter,
      requestorId: req.user.id,
      approverId: approverId || req.user.id,
      notes,
      createdById: req.user.id,
      updatedById: req.user.id
    });
    
    const purchaseRequisition = await models.PurchaseRequisition.create({
      prNumber,
      description,
      status: 'draft',
      totalAmount,
      currency: currency || 'USD',
      costCenter,
      requestorId: req.user.id,
      approverId: approverId || req.user.id, // Use requestor as temporary approver until submission
      notes,
      createdById: req.user.id,
      updatedById: req.user.id
    }, { transaction });
    
    console.log('‚úÖ PR created with ID:', purchaseRequisition.id);      // Create purchase requisition items
    console.log('üì¶ Creating PR items...');
    const prItems = [];
    for (const item of items) {
      console.log('üîç Processing item:', item);
      
      // Check if contract ID is provided and is valid
      if (item.contractId) {
        console.log('üîç Checking contract...');
        const contract = await Contract.findByPk(item.contractId);
        if (!contract) {
          throw new Error(`Contract with ID ${item.contractId} not found`);
        }
      }
        // Check if supplier ID is provided and is valid
      if (item.supplierId) {
        console.log('üîç Checking supplier...');
        const supplier = await models.Supplier.findByPk(item.supplierId);
        if (!supplier) {
          throw new Error(`Supplier with ID ${item.supplierId} not found`);
        }
      }
      
      // Check if item number is provided and is valid
      if (item.itemNumber) {
        console.log('üîç Checking item master...');
        const itemMaster = await ItemMaster.findOne({ 
          where: { itemNumber: item.itemNumber }
        });
        if (!itemMaster) {
          throw new Error(`Item with number ${item.itemNumber} not found`);
        }
      }
        // Check if inventory ID is provided
      let itemMasterId = null;      
      if (item.inventoryId) {
        console.log('üîç Checking inventory...');
        const inventory = await Inventory.findByPk(item.inventoryId);
        if (!inventory) {
          throw new Error(`Inventory with ID ${item.inventoryId} not found`);
        }
        itemMasterId = inventory.itemMasterId;
      }        const totalPrice = item.unitPrice && item.quantity 
        ? parseFloat(item.unitPrice) * parseFloat(item.quantity) 
        : 0;
      
      // Map frontend field names to backend
      const itemDescription = item.description || item.itemName || 'Unnamed Item';
      
      console.log('üìù Creating PR item with data:', {
        purchaseRequisitionId: purchaseRequisition.id,
        itemNumber: item.itemNumber || null,
        description: itemDescription,
        uom: item.uom,
        quantity: item.quantity,
        unitPrice: item.unitPrice || 0,
        totalPrice,
        contractId: item.contractId || null,
        supplierId: item.supplierId || null,
        supplierName: item.supplierName || null,
        comments: item.comments || null,
        deliveryDate: item.deliveryDate || null,
        inventoryId: item.inventoryId || null,
        itemMasterId: itemMasterId || item.itemMasterId || null,
        inventoryNumber: item.inventoryNumber || null,
        status: 'pending'
      });
      
      const prItem = await PurchaseRequisitionItem.create({
        purchaseRequisitionId: purchaseRequisition.id,
        itemNumber: item.itemNumber || null,
        description: itemDescription,
        uom: item.uom,
        quantity: item.quantity,
        unitPrice: item.unitPrice || 0,
        totalPrice,
        contractId: item.contractId || null,
        supplierId: item.supplierId || null,
        supplierName: item.supplierName || null,
        comments: item.comments || null,
        deliveryDate: item.deliveryDate || null,
        inventoryId: item.inventoryId || null,
        itemMasterId: itemMasterId || item.itemMasterId || null,
        inventoryNumber: item.inventoryNumber || null,        status: 'pending'
      }, { transaction });
      
      console.log('‚úÖ PR item created with ID:', prItem.id);
      prItems.push(prItem);
    }
    
    console.log('‚úÖ All PR items created successfully');
    await transaction.commit();
    console.log('‚úÖ Transaction committed successfully');
      res.status(201).json({
      success: true,
      message: 'Purchase Requisition created successfully',
      result: {
        id: purchaseRequisition.id,
        prNumber: purchaseRequisition.prNumber,
        number: purchaseRequisition.prNumber, // For frontend compatibility
        items: prItems.map(item => ({
          id: item.id,
          description: item.description,
          quantity: item.quantity,
          unitPrice: item.unitPrice,
          totalPrice: item.totalPrice
        }))
      },
      data: {
        id: purchaseRequisition.id,
        prNumber: purchaseRequisition.prNumber,
        items: prItems.map(item => ({
          id: item.id,
          description: item.description,
          quantity: item.quantity,
          unitPrice: item.unitPrice,
          totalPrice: item.totalPrice
        }))
      }
    });  } catch (error) {
    console.error('‚ùå Error creating Purchase Requisition:', error);
    console.error('‚ùå Error stack:', error.stack);
    await transaction.rollback();
    console.log('üîÑ Transaction rolled back');
    res.status(500).json({
      success: false,
      message: 'Failed to create Purchase Requisition',
      error: error.message
    });
  }
};

// @desc    Get all purchase requisitions
// @route   GET /api/procurement/purchase-requisition
// @access  Private
exports.getPurchaseRequisitions = async (req, res) => {
  try {
    console.log('üìã Getting purchase requisitions...');
    
    // Debug log for available tables
    console.log(`üîç PurchaseRequisition table name: ${PurchaseRequisition.tableName || 'Not defined'}`);
    
    try {
      // Try a raw query to see what's available
      const [tables] = await sequelize.query(`
        SELECT table_name 
        FROM information_schema.tables 
        WHERE table_schema = 'public'
      `);
      console.log('üìä Available tables:', tables.map(t => t.table_name));
    } catch (dbErr) {
      console.error('‚ùå Failed to query tables:', dbErr.message);
    }
    
    // Build query based on query parameters
    const query = {};
    const { status, requestorId, approverId, dateFrom, dateTo, search } = req.query;
    
    if (status) {
      query.status = status;
    }
    
    if (requestorId) {
      query.requestorId = requestorId;
    }
    
    if (approverId) {
      query.approverId = approverId;
    }
    
    // Date range filter
    if (dateFrom || dateTo) {
      query.createdAt = {};
      if (dateFrom) {
        query.createdAt[Op.gte] = new Date(dateFrom);
      }
      if (dateTo) {
        query.createdAt[Op.lte] = new Date(dateTo);
      }
    }
    
    // Search by PR number or description
    if (search) {
      query[Op.or] = [
        { prNumber: { [Op.like]: `%${search}%` } },
        { description: { [Op.like]: `%${search}%` } }
      ];
    }
    
    // Determine if we should filter by current user's role
    const isAdmin = req.user.role === 'admin';
    const isProcurementManager = req.user.role === 'procurement_manager';
    
    // Regular users can only see their own PRs or ones they need to approve
    if (!isAdmin && !isProcurementManager) {
      query[Op.or] = [
        { requestorId: req.user.id },
        { currentApproverId: req.user.id }
      ];
    }
      console.log('üîç Query:', JSON.stringify(query));
    
    try {
      const purchaseRequisitions = await models.PurchaseRequisition.findAll({
        where: query,
        include: [
          {
            model: User,
            as: 'requestor',
            attributes: ['id', 'name', 'email'],
            required: false
          },
          {
            model: User,
            as: 'approver',
            attributes: ['id', 'name', 'email'],
            required: false
          },
          {
            model: User,
            as: 'currentApprover',
            attributes: ['id', 'name', 'email'],
            required: false
          },
          {
            model: User,
            as: 'createdBy',
            attributes: ['id', 'name', 'email'],
            required: false
          },
          {
            model: PurchaseRequisitionItem,
            as: 'items',
            required: false
          }
        ],
        order: [['createdAt', 'DESC']]
      });
      
      console.log(`‚úÖ Found ${purchaseRequisitions.length} purchase requisitions`);
      
      // Debug: Check if associations are working
      if (purchaseRequisitions.length > 0) {
        const firstPR = purchaseRequisitions[0];
        console.log('üîç First PR data sample:', {
          id: firstPR.id,
          prNumber: firstPR.prNumber,
          requestor: firstPR.requestor ? firstPR.requestor.name : 'NO REQUESTOR',
          createdBy: firstPR.createdBy ? firstPR.createdBy.name : 'NO CREATED BY',
          approver: firstPR.approver ? firstPR.approver.name : 'NO APPROVER'
        });
      }
      
      res.status(200).json({
        success: true,
        count: purchaseRequisitions.length,
        data: purchaseRequisitions
      });
    } catch (queryErr) {
      console.error('‚ùå Error in findAll query:', queryErr);
      // Try a more basic query
      console.log('Attempting simpler query...');
      
      try {
        // Try direct SQL query as fallback
        const [rows] = await sequelize.query(`
          SELECT * FROM "PurchaseRequisitions" LIMIT 10
        `);
        
        console.log(`‚úÖ Found ${rows.length} rows via direct SQL`);
        
        res.status(200).json({
          success: true,
          count: rows.length,
          data: rows,
          note: 'Data retrieved via fallback direct SQL query'
        });
      } catch (sqlErr) {
        console.error('‚ùå Direct SQL query also failed:', sqlErr.message);
        throw queryErr; // rethrow the original error
      }
    }
  } catch (error) {
    console.error('‚ùå Failed to fetch Purchase Requisitions:', error);
    console.error('Call stack:', error.stack);
    
    res.status(500).json({
      success: false,
      message: 'Failed to fetch Purchase Requisitions',
      error: error.message,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
};

// @desc    Get a single purchase requisition
// @route   GET /api/procurement/purchase-requisition/:id
// @access  Private
exports.getPurchaseRequisition = async (req, res) => {
  try {
    const purchaseRequisition = await models.PurchaseRequisition.findByPk(req.params.id, {
      include: [
        {
          model: User,
          as: 'requestor',
          attributes: ['id', 'name', 'email']
        },
        {
          model: User,
          as: 'approver',
          attributes: ['id', 'name', 'email']
        },
        {
          model: User,
          as: 'currentApprover',
          attributes: ['id', 'name', 'email']
        },
        {
          model: PurchaseRequisitionItem,
          as: 'items',
          include: [
            {
              model: ItemMaster,
              as: 'itemMaster',
              attributes: ['id', 'itemNumber', 'shortDescription', 'longDescription', 'uom', 'manufacturerName', 'manufacturerPartNumber']
            },
            {
              model: Inventory,
              as: 'inventory',
              attributes: ['id', 'inventoryNumber', 'physicalBalance', 'unitPrice', 'minimumLevel', 'warehouse', 'binLocationText']
            },
            {
              model: ItemMaster,
              as: 'itemMasterDirect',
              attributes: ['id', 'itemNumber', 'shortDescription', 'longDescription', 'uom', 'manufacturerName', 'manufacturerPartNumber']
            },
            {
              model: Contract,
              as: 'contract',
              attributes: ['id', 'contractNumber', 'contractName']
            },
            {
              model: Supplier,
              as: 'supplier',
              attributes: ['id', 'supplierNumber', 'legalName', 'tradeName']
            }
          ]
        },
        {
          model: ApprovalHistory,
          as: 'approvalHistory',
          include: [
            {
              model: User,
              as: 'approver',
              attributes: ['id', 'name', 'email']
            }
          ]
        }
      ]
    });
    
    if (!purchaseRequisition) {
      return res.status(404).json({
        success: false,
        message: 'Purchase Requisition not found'
      });
    }
    
    // Check authorization - only requestor, approvers, admin and procurement managers can view
    const isRequestor = purchaseRequisition.requestorId === req.user.id;
    const isApprover = purchaseRequisition.approverId === req.user.id || 
                      purchaseRequisition.currentApproverId === req.user.id;
    const isAdmin = req.user.role === 'admin';
    const isProcurementManager = req.user.role === 'procurement_manager';
    
    if (!isRequestor && !isApprover && !isAdmin && !isProcurementManager) {
      return res.status(403).json({
        success: false,
        message: 'Not authorized to view this Purchase Requisition'
      });
    }
    
    res.status(200).json({
      success: true,
      data: purchaseRequisition
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Failed to fetch Purchase Requisition',
      error: error.message
    });
  }
};

// @desc    Update a purchase requisition
// @route   PUT /api/procurement/purchase-requisition/:id
// @access  Private
exports.updatePurchaseRequisition = async (req, res) => {
  const transaction = await sequelize.transaction();
  
  try {
    const { 
      description, 
      costCenter, 
      currency, 
      approverId,
      notes,
      items 
    } = req.body;
    
    const purchaseRequisition = await models.PurchaseRequisition.findByPk(req.params.id);
    
    if (!purchaseRequisition) {
      await transaction.rollback();
      return res.status(404).json({
        success: false,
        message: 'Purchase Requisition not found'
      });
    }
    
    // Check authorization - only requestor or admin can update
    const isRequestor = purchaseRequisition.requestorId === req.user.id;
    const isAdmin = req.user.role === 'admin';
    
    if (!isRequestor && !isAdmin) {
      await transaction.rollback();
      return res.status(403).json({
        success: false,
        message: 'Not authorized to update this Purchase Requisition'
      });
    }
    
    // PR can only be updated if in draft status
    if (purchaseRequisition.status !== 'draft') {
      await transaction.rollback();
      return res.status(400).json({
        success: false,
        message: 'Purchase Requisition can only be updated when in draft status'
      });
    }
    
    // Update PR
    if (description) purchaseRequisition.description = description;
    if (costCenter) purchaseRequisition.costCenter = costCenter;
    if (currency) purchaseRequisition.currency = currency;
    if (approverId) purchaseRequisition.approverId = approverId;
    if (notes !== undefined) purchaseRequisition.notes = notes;
    
    purchaseRequisition.updatedById = req.user.id;
    
    // Calculate total amount if items are provided
    if (items && items.length > 0) {
      let totalAmount = 0;
        // Delete existing items
      await PurchaseRequisitionItem.destroy({
        where: { purchaseRequisitionId: purchaseRequisition.id },
        transaction
      });
      
      // Create new items
      for (const item of items) {
        // Check if contract ID is provided and is valid
        if (item.contractId) {
          const contract = await Contract.findByPk(item.contractId);
          if (!contract) {
            throw new Error(`Contract with ID ${item.contractId} not found`);
          }
        }
        
        // Check if supplier ID is provided and is valid
        if (item.supplierId) {
          const supplier = await models.Supplier.findByPk(item.supplierId);
          if (!supplier) {
            throw new Error(`Supplier with ID ${item.supplierId} not found`);
          }
        }
        
        // Check if item number is provided and is valid
        if (item.itemNumber) {
          const itemMaster = await ItemMaster.findOne({ 
            where: { itemNumber: item.itemNumber }
          });
          if (!itemMaster) {
            throw new Error(`Item with number ${item.itemNumber} not found`);
          }
        }
        
        const totalPrice = item.unitPrice && item.quantity 
          ? parseFloat(item.unitPrice) * parseFloat(item.quantity) 
          : 0;
            await PurchaseRequisitionItem.create({
          purchaseRequisitionId: purchaseRequisition.id,
          itemNumber: item.itemNumber || null,
          description: item.description,
          uom: item.uom,
          quantity: item.quantity,
          unitPrice: item.unitPrice || 0,
          totalPrice,
          contractId: item.contractId || null,
          supplierId: item.supplierId || null,
          supplierName: item.supplierName || null,
          comments: item.comments || null,
          deliveryDate: item.deliveryDate || null,
          status: 'pending'
        }, { transaction });
        
        totalAmount += totalPrice;
      }
      
      purchaseRequisition.totalAmount = totalAmount;
    }
    
    await purchaseRequisition.save({ transaction });
    await transaction.commit();
    
    res.status(200).json({
      success: true,
      message: 'Purchase Requisition updated successfully',
      data: purchaseRequisition
    });
  } catch (error) {
    await transaction.rollback();
    res.status(500).json({
      success: false,
      message: 'Failed to update Purchase Requisition',
      error: error.message
    });
  }
};

// @desc    Submit a purchase requisition for approval
// @route   PUT /api/procurement/purchase-requisition/:id/submit
// @access  Private
exports.submitPurchaseRequisition = async (req, res) => {
  const transaction = await sequelize.transaction();
  
  try {
    const pr = await models.PurchaseRequisition.findByPk(req.params.id, {
      include: [
        {
          model: User,
          as: 'requestor',
          attributes: ['id', 'name', 'email', 'role']
        }
      ],
      transaction
    });

    if (!pr) {
      await transaction.rollback();
      return res.status(404).json({
        success: false,
        message: 'Purchase Requisition not found'
      });
    }

    if (pr.status !== 'draft') {
      await transaction.rollback();
      return res.status(400).json({
        success: false,
        message: 'Only draft PRs can be submitted for approval'
      });
    }    // Get current user (the one submitting)
    const currentUser = req.user;
    console.log(`üîç User submitting PR: ${currentUser?.name} (${currentUser?.role})`);

    // When submitting, ALWAYS go to pending_approval status first
    // The approval is a separate action that happens later
    
    let nextApprover = null;
    
    // Determine who should approve based on user roles and amount
    if (currentUser?.role === 'admin') {
      // For admins, find another admin or procurement_manager to approve
      const otherApprover = await User.findOne({
        where: { 
          role: ['admin', 'procurement_manager'], 
          isActive: true,
          id: { [Op.ne]: currentUser.id } // Not the same user
        },
        transaction
      });
      nextApprover = otherApprover;
    } else if (currentUser?.role === 'procurement_manager') {
      // Procurement managers need admin approval
      const admin = await User.findOne({
        where: { role: 'admin', isActive: true },
        transaction
      });
      nextApprover = admin;
    } else if (currentUser?.role === 'manager') {
      // Managers need admin or procurement_manager approval
      const approver = await User.findOne({
        where: { role: ['admin', 'procurement_manager'], isActive: true },
        transaction
      });
      nextApprover = approver;
    } else {
      // Staff/regular users need manager, admin, or procurement_manager approval
      const approver = await User.findOne({
        where: { role: ['manager', 'admin', 'procurement_manager'], isActive: true },
        transaction
      });
      nextApprover = approver;
    }

    // Update PR to pending_approval status
    await pr.update({
      status: 'pending_approval',
      submittedAt: new Date(),
      currentApproverId: nextApprover?.id || null
    }, { transaction });

    // Create approval history record for submission
    try {
      const DirectApprovalHistory = ApprovalHistory || models.ApprovalHistory;
      await DirectApprovalHistory.create({
        referenceType: 'PurchaseRequisition',
        referenceId: pr.id,
        approverId: nextApprover?.id || currentUser.id,
        level: 1,
        status: 'pending',
        comments: `Submitted for approval by ${currentUser?.name}${nextApprover ? ` - Assigned to ${nextApprover.name}` : ' - Manual approval required'}`
      }, { transaction });
    } catch (historyError) {
      console.warn('‚ö†Ô∏è Could not create approval history:', historyError.message);
      // Continue without failing the submission
    }

    await transaction.commit();

    return res.json({
      success: true,
      message: `Purchase Requisition submitted for approval${nextApprover ? ` - Assigned to ${nextApprover.name}` : ' - Manual approval required'}`,
      data: pr
    });
      }
    } else if (currentUser?.role === 'procurement_manager') {
      // Procurement managers can approve their own PRs up to $50,000
      if (pr.totalAmount < 50000) {
        newStatus = 'approved';
        await pr.update({
          status: newStatus,
          submittedAt: new Date(),
          approvedAt: new Date(),
          approverId: currentUser.id,
          currentApproverId: null
        }, { transaction });
        
        await ApprovalHistory.create({
          referenceType: 'PurchaseRequisition',
          referenceId: pr.id,
          approverId: currentUser.id,
          level: 1,
          status: 'approved',
          comments: 'Auto-approved by procurement manager',
          actionDate: new Date()
        }, { transaction });
        
        await transaction.commit();
        
        return res.json({
          success: true,
          message: 'Purchase Requisition approved successfully (procurement manager auto-approval)',
          data: pr
        });
      } else {
        // For larger amounts, send to admin
        const admin = await User.findOne({
          where: { role: 'admin', isActive: true },
          transaction
        });
        nextApprover = admin;
      }
    } else if (currentUser?.role === 'manager') {
      // Managers can approve small PRs, others go to procurement_manager or admin
      if (pr.totalAmount < 5000) {
        newStatus = 'approved';
        await pr.update({
          status: newStatus,
          submittedAt: new Date(),
          approvedAt: new Date(),
          approverId: currentUser.id,
          currentApproverId: null
        }, { transaction });
        
        await ApprovalHistory.create({
          referenceType: 'PurchaseRequisition',
          referenceId: pr.id,
          approverId: currentUser.id,
          level: 1,
          status: 'approved',
          comments: 'Auto-approved by manager',
          actionDate: new Date()
        }, { transaction });
        
        await transaction.commit();
        
        return res.json({
          success: true,
          message: 'Purchase Requisition approved successfully (manager auto-approval)',
          data: pr
        });
      } else {
        // Send to procurement manager or admin
        const procurementManager = await User.findOne({
          where: { role: 'procurement_manager', isActive: true },
          transaction
        });
        nextApprover = procurementManager || await User.findOne({
          where: { role: 'admin', isActive: true },
          transaction
        });
      }
    } else {
      // Staff and other roles need approval from manager, procurement_manager, or admin
      const manager = await User.findOne({
        where: { role: 'manager', isActive: true },
        transaction
      });
      const procurementManager = await User.findOne({
        where: { role: 'procurement_manager', isActive: true },
        transaction
      });
      const admin = await User.findOne({
        where: { role: 'admin', isActive: true },
        transaction
      });
      
      // Choose the appropriate approver based on amount
      if (pr.totalAmount < 1000) {
        nextApprover = manager || procurementManager || admin;
      } else if (pr.totalAmount < 10000) {
        nextApprover = procurementManager || admin;
      } else {
        nextApprover = admin;
      }
    }

    // If no approver found, return error
    if (!nextApprover && newStatus === 'pending_approval') {
      await transaction.rollback();
      return res.status(400).json({
        success: false,
        message: 'No available approver found for this PR'
      });
    }

    // Update PR with submission details
    await pr.update({
      status: newStatus,
      submittedAt: new Date(),
      currentApproverId: nextApprover?.id || null
    }, { transaction });

    // Create approval history record for submission
    await ApprovalHistory.create({
      referenceType: 'PurchaseRequisition',
      referenceId: pr.id,
      approverId: nextApprover?.id || currentUser.id,
      level: 1,
      status: 'pending',
      comments: `Submitted for approval by ${currentUser?.name} (${currentUser?.role})`
    }, { transaction });

    await transaction.commit();

    // Notify approver if needed
    if (nextApprover) {
      await notifyApprover(pr, nextApprover);
    }

    res.json({
      success: true,
      message: `PR submitted successfully - ${nextApprover ? `pending approval from ${nextApprover.name} (${nextApprover.role})` : 'auto-approved'}`,
      data: {
        id: pr.id,
        status: newStatus,
        nextApprover: nextApprover ? {
          id: nextApprover.id,
          name: nextApprover.name,
          role: nextApprover.role
        } : null
      }
    });
  } catch (error) {
    await transaction.rollback();
    console.error('Error submitting PR:', error);
    res.status(500).json({
      success: false,
      message: 'Error submitting PR',
      error: error.message
    });
  }
};

// @desc    Approve or reject a purchase requisition
// @route   PUT /api/procurement/purchase-requisition/:id/approve
// @access  Private
exports.approvePurchaseRequisition = async (req, res) => {
  const transaction = await sequelize.transaction();
  
  try {
    const { action, comments } = req.body;
    
    if (!['approve', 'reject'].includes(action)) {
      await transaction.rollback();
      return res.status(400).json({
        success: false,
        message: 'Invalid action'
      });
    }    const pr = await models.PurchaseRequisition.findByPk(req.params.id, {
      include: [
        {
          model: User,
          as: 'requestor',
          attributes: ['id', 'name', 'email']
        },
        {
          model: ApprovalHistory,
          as: 'approvalHistory',
          include: [{
            model: User,
            as: 'approver',
            attributes: ['id', 'name', 'email']
          }]
        }
      ],
      transaction
    });

    if (!pr) {
      await transaction.rollback();
      return res.status(404).json({
        success: false,
        message: 'Purchase Requisition not found'
      });
    }

    if (pr.currentApproverId !== req.user.id) {
      await transaction.rollback();
      return res.status(403).json({
        success: false,
        message: 'You are not the current approver of this PR'
      });
    }

    const currentApproval = pr.approvals.find(a => a.approverId === req.user.id && a.status === 'pending');
    
    if (!currentApproval) {
      await transaction.rollback();
      return res.status(400).json({
        success: false,
        message: 'No pending approval found'
      });
    }

    // Update current approval
    await currentApproval.update({
      status: action === 'approve' ? 'approved' : 'rejected',
      comments,
      actionDate: new Date()
    }, { transaction });

    if (action === 'reject') {
      // Reject PR
      await pr.update({
        status: 'rejected',
        currentApproverId: null
      }, { transaction });

      // Notify requestor of rejection
      console.log(`‚úâÔ∏è Would notify ${pr.requestor.email} that PR ${pr.prNumber} was rejected`);
    } else {
      // Find next pending approval
      const nextApproval = pr.approvals
        .filter(a => a.status === 'pending')
        .sort((a, b) => a.approvalLevel - b.approvalLevel)[0];

      if (nextApproval) {
        // Update PR with next approver
        await pr.update({
          currentApproverId: nextApproval.approverId
        }, { transaction });

        // Notify next approver
        await notifyApprover(pr, nextApproval.approver);
      } else {
        // All approvals complete
        await pr.update({
          status: 'approved',
          currentApproverId: null
        }, { transaction });

        // Notify requestor of approval
        console.log(`‚úâÔ∏è Would notify ${pr.requestor.email} that PR ${pr.prNumber} was fully approved`);
      }
    }

    await transaction.commit();

    res.json({
      success: true,
      message: `PR ${action === 'approve' ? 'approved' : 'rejected'} successfully`
    });
  } catch (error) {
    await transaction.rollback();
    console.error('Error processing PR approval:', error);
    res.status(500).json({
      success: false,
      message: 'Error processing PR approval',
      error: error.message
    });
  }
};

// @desc    Delete a purchase requisition
// @route   DELETE /api/procurement/purchase-requisition/:id
// @access  Private
exports.deletePurchaseRequisition = async (req, res) => {
  const transaction = await sequelize.transaction();
  
  try {
    const purchaseRequisition = await models.PurchaseRequisition.findByPk(req.params.id);
    
    if (!purchaseRequisition) {
      await transaction.rollback();
      return res.status(404).json({
        success: false,
        message: 'Purchase Requisition not found'
      });
    }
    
    // Check authorization - only requestor or admin can delete
    const isRequestor = purchaseRequisition.requestorId === req.user.id;
    const isAdmin = req.user.role === 'admin';
    
    if (!isRequestor && !isAdmin) {
      await transaction.rollback();
      return res.status(403).json({
        success: false,
        message: 'Not authorized to delete this Purchase Requisition'
      });
    }
    
    // PR can only be deleted if in draft status
    if (purchaseRequisition.status !== 'draft') {
      await transaction.rollback();
      return res.status(400).json({
        success: false,
        message: 'Purchase Requisition can only be deleted when in draft status'
      });
    }
      // Delete PR items
    await PurchaseRequisitionItem.destroy({
      where: { purchaseRequisitionId: purchaseRequisition.id },
      transaction
    });
    
    // Delete PR
    await purchaseRequisition.destroy({ transaction });
    
    await transaction.commit();
    
    res.status(200).json({
      success: true,
      message: 'Purchase Requisition deleted successfully'
    });
  } catch (error) {
    await transaction.rollback();
    res.status(500).json({
      success: false,
      message: 'Failed to delete Purchase Requisition',
      error: error.message
    });
  }
};

// @desc    Get pending approvals for current user
// @route   GET /api/procurement/purchase-requisition/pending-approvals
// @access  Private
exports.getPendingApprovals = async (req, res) => {
  try {
    const pendingPRs = await models.PurchaseRequisition.findAll({
      where: {
        status: 'pending_approval',
        currentApproverId: req.user.id
      },
      include: [
        {
          model: User,
          as: 'requestor',
          attributes: ['id', 'name', 'email']
        },        {
          model: ApprovalHistory,
          as: 'approvalHistory',
          where: {
            approverId: req.user.id,
            status: 'pending'
          },
          required: true
        },
        {
          model: PurchaseRequisitionItem,
          as: 'items'
        }
      ],
      order: [['createdAt', 'DESC']]
    });

    res.json({
      success: true,
      data: pendingPRs
    });
  } catch (error) {
    console.error('Error fetching pending approvals:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching pending approvals',
      error: error.message
    });
  }
};
